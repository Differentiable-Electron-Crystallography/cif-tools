// tests/integration/pycifrw_xanthine.rs
// Integration tests for CIF file generated by PyCifRW module
// Structure: Xanthine (form 1) - a purine base

use crate::fixture_path;
use cif_parser::Document;

#[test]
fn test_parse_pycifrw_xanthine() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).expect("Failed to parse PyCifRW xanthine CIF");

    assert_eq!(doc.blocks.len(), 1);
    let block = &doc.blocks[0];
    assert_eq!(block.name, "xanthine_form_1");
}

#[test]
fn test_pycifrw_xanthine_cell_parameters() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    // Monoclinic crystal system
    assert_eq!(
        block
            .get_item("_symmetry_cell_setting")
            .unwrap()
            .as_string()
            .unwrap(),
        "monoclinic"
    );

    // PyCifRW outputs values with uncertainty: 10.01(11)
    // These are now correctly parsed as NumericWithUncertainty
    let a = block
        .get_item("_cell_length_a")
        .unwrap()
        .as_numeric()
        .unwrap();
    let b = block
        .get_item("_cell_length_b")
        .unwrap()
        .as_numeric()
        .unwrap();
    let c = block
        .get_item("_cell_length_c")
        .unwrap()
        .as_numeric()
        .unwrap();

    assert!((a - 10.01).abs() < 0.01);
    assert!((b - 18.23).abs() < 0.01);
    assert!((c - 6.93).abs() < 0.01);

    // Monoclinic: alpha = gamma = 90, beta != 90
    assert_eq!(
        block
            .get_item("_cell_angle_alpha")
            .unwrap()
            .as_numeric()
            .unwrap(),
        90.0
    );
    assert_eq!(
        block
            .get_item("_cell_angle_gamma")
            .unwrap()
            .as_numeric()
            .unwrap(),
        90.0
    );

    // Beta angle with uncertainty: 107.5(9)
    let beta = block
        .get_item("_cell_angle_beta")
        .unwrap()
        .as_numeric()
        .unwrap();
    assert!((beta - 107.5).abs() < 0.1);
}

#[test]
fn test_pycifrw_xanthine_space_group() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    assert_eq!(
        block
            .get_item("_symmetry_space_group_name_H-M")
            .unwrap()
            .as_string()
            .unwrap(),
        "P 21/c"
    );
    assert_eq!(
        block
            .get_item("_symmetry_Int_Tables_number")
            .unwrap()
            .as_numeric()
            .unwrap(),
        14.0
    );
    assert_eq!(
        block
            .get_item("_space_group_name_Hall")
            .unwrap()
            .as_string()
            .unwrap(),
        "-P 2ybc"
    );
}

#[test]
fn test_pycifrw_xanthine_symmetry_operations() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    let symm_loop = block.find_loop("_symmetry_equiv_pos_site_id").unwrap();

    // P21/c has 4 symmetry operations
    assert_eq!(symm_loop.len(), 4);

    // Check tags - PyCifRW uses indented format
    assert!(symm_loop
        .tags
        .contains(&"_symmetry_equiv_pos_site_id".to_string()));
    assert!(symm_loop
        .tags
        .contains(&"_symmetry_equiv_pos_as_xyz".to_string()));

    // First operation is identity
    assert_eq!(
        symm_loop
            .get_by_tag(0, "_symmetry_equiv_pos_as_xyz")
            .unwrap()
            .as_string()
            .unwrap(),
        "x,y,z"
    );

    // Site IDs should be numeric
    assert_eq!(
        symm_loop
            .get_by_tag(0, "_symmetry_equiv_pos_site_id")
            .unwrap()
            .as_numeric()
            .unwrap(),
        1.0
    );
}

#[test]
fn test_pycifrw_xanthine_atom_sites() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    let atom_loop = block.find_loop("_atom_site_label").unwrap();

    // Xanthine has 2 molecules in asymmetric unit (Z'=2)
    // Each molecule: C5H4N4O2 = 15 atoms
    // Total: 30 atoms
    assert_eq!(atom_loop.len(), 30);

    // Check that we have expected atom types
    let atom_types: Vec<&str> = (0..30)
        .map(|i| {
            atom_loop
                .get_by_tag(i, "_atom_site_type_symbol")
                .unwrap()
                .as_string()
                .unwrap()
        })
        .collect();

    // Count atom types
    let n_count = atom_types.iter().filter(|&&t| t == "N").count();
    let c_count = atom_types.iter().filter(|&&t| t == "C").count();
    let o_count = atom_types.iter().filter(|&&t| t == "O").count();
    let h_count = atom_types.iter().filter(|&&t| t == "H").count();

    // 2 molecules × 4 N = 8 N
    assert_eq!(n_count, 8);
    // 2 molecules × 5 C = 10 C
    assert_eq!(c_count, 10);
    // 2 molecules × 2 O = 4 O
    assert_eq!(o_count, 4);
    // 2 molecules × 4 H = 8 H
    assert_eq!(h_count, 8);
}

#[test]
fn test_pycifrw_xanthine_fractional_coordinates() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    let atom_loop = block.find_loop("_atom_site_label").unwrap();

    // All fractional coordinates should be in [0, 1) or near that range
    for i in 0..atom_loop.len() {
        let x = atom_loop
            .get_by_tag(i, "_atom_site_fract_x")
            .unwrap()
            .as_numeric()
            .unwrap();
        let y = atom_loop
            .get_by_tag(i, "_atom_site_fract_y")
            .unwrap()
            .as_numeric()
            .unwrap();
        let z = atom_loop
            .get_by_tag(i, "_atom_site_fract_z")
            .unwrap()
            .as_numeric()
            .unwrap();

        // Coordinates should be reasonable (between -0.5 and 1.5)
        assert!(
            x > -0.5 && x < 1.5,
            "x coordinate {} out of range for atom {}",
            x,
            i
        );
        assert!(
            y > -0.5 && y < 1.5,
            "y coordinate {} out of range for atom {}",
            y,
            i
        );
        assert!(
            z > -0.5 && z < 1.5,
            "z coordinate {} out of range for atom {}",
            z,
            i
        );
    }
}

#[test]
fn test_pycifrw_xanthine_thermal_parameters() {
    let path = fixture_path("pycifrw_xanthine.cif");
    let doc = Document::from_file(&path).unwrap();
    let block = &doc.blocks[0];

    let atom_loop = block.find_loop("_atom_site_label").unwrap();

    // Check thermal displacement type is Uiso for all atoms
    for i in 0..atom_loop.len() {
        let thermal_type = atom_loop
            .get_by_tag(i, "_atom_site_thermal_displace_type")
            .unwrap()
            .as_string()
            .unwrap();
        assert_eq!(thermal_type, "Uiso");

        // U_iso values should be positive and reasonable (< 0.1 Å²)
        let u_iso = atom_loop
            .get_by_tag(i, "_atom_site_U_iso_or_equiv")
            .unwrap()
            .as_numeric()
            .unwrap();
        assert!(u_iso > 0.0, "U_iso should be positive");
        assert!(
            u_iso < 0.1,
            "U_iso {} unusually large for atom {}",
            u_iso,
            i
        );
    }
}
