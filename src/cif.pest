// ================================================================================
// CIF 2.0 Grammar in Pest PEG Format
// ================================================================================
//
// Based on the formal CIF 2.0 EBNF specification from:
// https://www.iucr.org/__data/assets/text_file/0009/112131/CIF2-ENBF.txt
// With further refence to the CIF 1.1 specification here:
// https://www.iucr.org/resources/cif/spec/version1.1/cifsyntax#intro
//
// This PEG grammar uses the CIF 2.0 EBNF defined syntax wherever possible, however if the
// CIF 2.0 grammar is different from the CIF 1.1 syntax (which is less rigorously defined) using an ENBF-esque
// syntax defined in a series of paragraphs here: https://www.iucr.org/resources/cif/spec/version1.1/cifsyntax#intro.
// Then the PEG grammar of this file will use the CIF 1.1 specification.
//
// This means the formal grammar of this parser is a non-mutually-exclusive union of the CIF2.0 and CIF1.1 grammars.
// Where CIF2.0 grammars diverge, this parser handles them not here in the PEG but as "semantic" rules encoded in the
// Parser. These semantic rules can be found in the parser because they are guarded by a check for the document's
// CIF version. The bifurcation is further reflected in /tests/parser/grammar_tests and /tests/parser/semantic_tests.
//
// Naming conventions:
// - CIF 2.0 EBNF uses hyphenated names (data-heading, container-code)
// - Pest uses snake_case (data_heading, container_code)
// - Production names match CIF 2.0 EBNF names (which differ from CIF 1.0) where possible.
//
// ================================================================================

// ===== PART 1: CHARACTER SET =====
// Reference: CIF 2.0 EBNF "allchars" production

// CIF 2.0 EBNF: allchars = ?U+0009? | ?U+000A? | ?U+000D? | ?U+0020 - U+007E?
//   | ?U+00A0 - U+D7FF? | ?U+E000 - U+FDCF? | ?U+FDF0 - U+FFFD?
//   | ?U+10000 - U+1FFFD? | ... (all Unicode planes to U+10FFFD)
//
// Allowed characters: Tab, LF, CR, and most Unicode code points
// Excluded: Control characters, surrogates, non-characters
//
// Pest implementation: Use ANY token (all Unicode) with explicit exclusions
allchars = { ANY }

// CIF 2.0 EBNF: char = allchars - line-term
// Any allowed character except line terminators
char = { !line_term ~ ANY }

// CIF 2.0 EBNF: non-blank-char = char - inline-wspace
// Any character except space, tab, and line terminators
//
// CIF 1.1 Note: Was limited to ASCII printable (U+0021 to U+007E)
non_blank_char = { !inline_wspace ~ char }

// ===== PART 2: WHITESPACE AND LINE ENDINGS =====
// Reference: CIF 2.0 EBNF whitespace productions

// CIF 2.0 EBNF: inline-wspace = ?U+0020? | ?U+0009?
// Only ASCII space and tab are significant as inline whitespace
inline_wspace = { " " | "\t" }

// CIF 2.0 EBNF: line-term = ( ?U+000D?, [ ?U+000A? ] ) | ?U+000A?
// Matches: CR, LF, or CRLF
// CIF 2.0 normalizes all line endings to LF semantically
line_term = { "\r\n" | "\r" | "\n" }

// CIF 2.0 EBNF: comment = '#', { char }
// A comment is a hash symbol followed by any characters until end of line
comment = { "#" ~ (!line_term ~ ANY)* }

// CIF 2.0 EBNF: wspace-to-eol = { inline-wspace }, [ comment ], line-term
// Whitespace (spaces/tabs), optional comment, ending with line terminator
wspace_to_eol = { inline_wspace* ~ comment? ~ line_term }

// CIF 2.0 EBNF: wspace-any = { wspace-to-eol }, { inline-wspace }
// Possibly-empty run of whitespace and comments; may span multiple lines
wspace_any = { wspace_to_eol* ~ inline_wspace* }

// CIF 2.0 EBNF: wspace-lines = [ inline-wspace, { inline-wspace }, [ comment ] ],
//                               line-term, { wspace-to-eol }
// Nonempty whitespace ending with line terminator; may span multiple lines
wspace_lines = { (inline_wspace+ ~ comment?)? ~ line_term ~ wspace_to_eol* }

// CIF 2.0 EBNF: wspace = ( inline-wspace | line-term ), wspace-any
// Nonempty run of whitespace and possibly comments; may span multiple lines
wspace = { (inline_wspace | line_term) ~ wspace_any }

// Backward compatibility aliases (CIF 1.1 naming)
ws_char = { inline_wspace | line_term }
whitespace = { wspace }
ws_or_eof = { wspace | EOI }

// ===== PART 3: RESERVED WORDS / KEYWORDS =====
// Reference: CIF 2.0 EBNF token productions

// CIF 2.0 EBNF: data-token = ( 'D' | 'd' ), ( 'A' | 'a' ), ( 'T' | 't' ), ( 'A' | 'a' ), '_'
// Case-insensitive "data_" keyword
data_token = { ^"data_" }

// CIF 2.0 EBNF: save-token = ( 'S' | 's' ), ( 'A' | 'a' ), ( 'V' | 'v' ), ( 'E' | 'e' ), '_'
// Case-insensitive "save_" keyword
save_token = { ^"save_" }

// CIF 2.0 EBNF: loop-token = ( 'L' | 'l' ), ( 'O' | 'o' ), ( 'O' | 'o' ), ( 'P' | 'p' ), '_'
// Case-insensitive "loop_" keyword
loop_token = { ^"loop_" ~ &ws_or_eof }

// CIF 2.0 EBNF: global-token = ( 'G' | 'g' ), ... , '_'
// Case-insensitive "global_" keyword (reserved, not used in CIF)
global_token = { ^"global_" ~ &ws_or_eof }

// CIF 2.0 EBNF: stop-token = ( 'S' | 's' ), ( 'T' | 't' ), ( 'O' | 'o' ), ( 'P' | 'p' ), '_'
// Case-insensitive "stop_" keyword (deprecated, reserved)
stop_token = { ^"stop_" ~ &ws_or_eof }

// Combined keyword matcher for exclusion in wsdelim_string
keyword = { data_token | save_token | loop_token | global_token | stop_token }

// Backward compatibility aliases (CIF 1.1 naming)
str_data = { data_token }
str_save = { save_token }
str_loop = { loop_token }
str_global = { global_token }
str_stop = { stop_token }

// ===== PART 4: STRING VALUES =====
// Reference: CIF 2.0 EBNF string productions

// --- 4.1: Simple Quoted Strings ---

// CIF 2.0 EBNF: quote-delim = '"'
quote_delim = { "\"" }

// CIF 2.0 EBNF: apostrophe-delim = "'"
apostrophe_delim = { "'" }

// CIF 1.1 quote escaping: quotes only end string if followed by whitespace, comment, or EOI
// This allows doubled quotes for escaping: 'O''Brien' and "He said ""Hi"""
// In CIF 2.0 files, the parser will semantically validate against this pattern
endq_double = { "\"" ~ &(ws_char | "#" | EOI) }
endq_single = { "'" ~ &(ws_char | "#" | EOI) }

// CIF 2.0 EBNF: quote-content = { char - quote-delim }
// Modified for CIF 1.1 compatibility: quotes that aren't followed by whitespace/comment/EOI
// are treated as regular characters (allowing doubled-quote escaping)
// CIF 1.1 Note: Did not allow newlines; CIF 2.0 does (we allow newlines for compatibility)
quote_content = { (!endq_double ~ char)* }

// CIF 2.0 EBNF: apostrophe-content = { char - apostrophe-delim }
apostrophe_content = { (!endq_single ~ char)* }

// CIF 2.0 EBNF: quoted-string = ( quote-delim, quote-content, quote-delim )
//                             | ( apostrophe-delim, apostrophe-content, apostrophe-delim )
// Single or double quoted strings with CIF 1.1 doubled-quote escaping support
quoted_string = {
    (quote_delim ~ quote_content ~ endq_double) |
    (apostrophe_delim ~ apostrophe_content ~ endq_single)
}

// Backward compatibility aliases (CIF 1.1 naming)
singlequoted = { apostrophe_delim ~ apostrophe_content ~ endq_single }
doublequoted = { quote_delim ~ quote_content ~ endq_double }

// --- 4.2: Triple-Quoted Strings (CIF 2.0 only) ---

// CIF 2.0 EBNF: quote3-delim = '"""'
quote3_delim = { "\"\"\"" }

// CIF 2.0 EBNF: apostrophe3-delim = "'''"
apostrophe3_delim = { "'''" }

// CIF 2.0 EBNF: quote3-content = { [ '"', [ '"' ] ], not-quote, { not-quote } }
// Content can contain single or double quotes, but not triple quotes
// Simplified implementation: Match anything until triple-quote delimiter
quote3_content = { (!"\"\"\"" ~ ANY)* }

// CIF 2.0 EBNF: apostrophe3-content = { [ "'", [ "'" ] ], not-apostrophe, { not-apostrophe } }
apostrophe3_content = { (!"'''" ~ ANY)* }

// CIF 2.0 EBNF: triple-quoted-string = ( quote3-delim, quote3-content, quote3-delim )
//                                    | ( apostrophe3-delim, apostrophe3-content, apostrophe3-delim )
triple_quoted_string = {
    (quote3_delim ~ quote3_content ~ quote3_delim) |
    (apostrophe3_delim ~ apostrophe3_content ~ apostrophe3_delim)
}

// --- 4.3: Text Fields (Semicolon-Delimited) ---

// CIF 2.0 EBNF: text-delim = line-term, ';'
// Text field delimiter: newline followed by semicolon at start of line
//
// IMPLEMENTATION NOTE: In dataitem context, the opening text field appears as:
//   _tag\n;content\n;
// The first \n is consumed by wspace between tag and value, so the opening delimiter
// is just ";" followed by content. The closing delimiter is \n; as expected.
text_delim = { line_term ~ ";" }

// CIF 2.0 EBNF: text-content = { allchars } - ( { allchars }, text-delim, { allchars } )
// Any content that doesn't contain the text delimiter
text_content = { (!text_delim ~ ANY)* }

// CIF 2.0 EBNF: text-field = text-delim, text-content, text-delim
// Multi-line text field bounded by semicolons at line starts
// Opening: ";" at start of line (line_term? handles both standalone and dataitem contexts)
//          Content can start on same line or next line after opening semicolon
// Closing: newline + ";" (standard text_delim)
// Note: line_term? is optional because in dataitem context, the preceding newline is
//       already consumed by wspace, but in standalone grammar tests, it's part of the input
text_field = { line_term? ~ ";" ~ text_content ~ text_delim }

// Backward compatibility alias (CIF 1.1 naming)
textfield = { text_field }

// --- 4.4: Whitespace-Delimited Strings (Unquoted) ---

// CIF 2.0 EBNF: restrict-char = non-blank-char - ( '[' | ']' | '{' | '}' )
// CIF 1.1 Note: Did not exclude [ ] { } (not needed without lists/tables)
//
// IMPLEMENTATION: Following CIF 2.0 spec strictly - exclude brackets and braces.
// This means that even in CIF 1.1 files, these characters must be quoted if used
// as literal text values. This is necessary for the PEG parser to correctly handle
// empty lists/tables in CIF 2.0 mode.
restrict_char = { !("[" | "]" | "{" | "}") ~ non_blank_char }

// CIF 2.0 EBNF: lead-char = restrict-char - ( '"' | '#' | "'" | '_' )
// First character of wsdelim string (excludes quote starters and data names)
lead_char = { !("\"" | "#" | "'" | "_") ~ restrict_char }

// CIF 2.0 EBNF: wsdelim-string = ( lead-char, {restrict-char} )
//     - ( ( data-token | save-token ), { non-blank-char } | loop-token | global-token | stop-token )
// Whitespace-delimited string that doesn't match keywords
//
// PERMISSIVE: Allows [{]}] for CIF 1.1 compatibility
// Parser will check version and parse [{] as list/table delimiters in CIF 2.0 mode
wsdelim_string = {
    !keyword ~
    lead_char ~
    restrict_char*
}

// CIF 2.0 EBNF: wsdelim-string-sol = wsdelim-string - ( ';', { non-blank-char } )
// wsdelim string at start of line (cannot start with semicolon)
wsdelim_string_sol = { !(";") ~ wsdelim_string }

// Backward compatibility alias (CIF 1.1 naming)
unquoted = { wsdelim_string }

// CIF 1.1 optimization (simple unquoted with ordinary chars only)
// Kept for performance, though ordinary_char is no longer explicitly defined
ordinary_char = {
    "!" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" |
    '0'..'9' | ":" | "<" | "=" | ">" | "?" | "@" | 'A'..'Z' | "\\" |
    "^" | "`" | 'a'..'z' | "|" | "~"
}
simunq = { ordinary_char+ ~ &ws_char }

// ===== PART 5: DATA STRUCTURES (CIF 2.0 only) =====
// Reference: CIF 2.0 EBNF composite value productions

// Forward declaration for recursive data_value
data_value = {
    triple_quoted_string |
    quoted_string |
    list |
    table |
    text_field |
    wsdelim_string
}

// --- 5.1: Lists ---

// CIF 2.0 EBNF: list = '[', [ list-values-start, { wspace-data-value } ], [ wspace ], ']'
// A list contains zero or more whitespace-separated data values
list = {
    "[" ~
    wspace_any ~
    (data_value ~ (wspace ~ data_value)*)? ~
    wspace? ~
    "]"
}

// --- 5.2: Tables ---

// CIF 2.0 table keys use strict quote matching (no doubled-quote escaping)
// This is necessary because table keys can be followed by ':' with no whitespace
table_key_quoted = {
    (quote_delim ~ (!quote_delim ~ char)* ~ quote_delim) |
    (apostrophe_delim ~ (!apostrophe_delim ~ char)* ~ apostrophe_delim)
}

// CIF 2.0 EBNF: table-entry = ( quoted-string | triple-quoted-string ),
//                             ':', ( nospace-value | wsdelim-string | wspace-data-value )
// Key-value pair in table (key must be quoted, value can be any data value)
// CIF 2.0 spec: Only inline whitespace (no newlines) allowed around colon
// NOTE: triple_quoted_string MUST come before table_key_quoted to avoid matching "" instead of """
// NOTE: table_key_quoted uses strict quote matching (not quoted_string with CIF 1.1 escaping)
table_entry = {
    (triple_quoted_string | table_key_quoted) ~
    inline_wspace* ~ ":" ~ inline_wspace* ~
    data_value
}

// CIF 2.0 EBNF: table = '{', [ wspace-any, table-entry, { wspace, table-entry } ], [ wspace ], '}'
// A table contains zero or more whitespace-separated key-value pairs
table = {
    "{" ~
    wspace_any ~
    (table_entry ~ (wspace ~ table_entry)*)? ~
    wspace? ~
    "}"
}

// ===== PART 6: DATA VALUES =====
// Reference: CIF 2.0 EBNF value productions

// Value types for parsing context (backward compatibility)
item_value = { data_value }
loop_value = { data_value }

// CIF 1.1 alias
value = { data_value }

// ===== PART 7: DATA NAMES =====
// Reference: CIF 2.0 EBNF data-name production

// CIF 2.0 EBNF: data-name = '_', non-blank-char, { non-blank-char }
// A data name (tag) starts with underscore followed by 1+ non-blank characters
//
// CIF 1.1 implementation: tag = { "_" ~ nonblank_ch+ }
// Status: ✅ Matches CIF 2.0
data_name = { "_" ~ non_blank_char+ }

// Backward compatibility aliases (CIF 1.1 naming)
tag = { data_name }
item_tag = { data_name }
loop_tag = { data_name }
nonblank_ch = { '\x21'..'\x7E' }  // Keep for CIF 1.1 compat

// ===== PART 8: DATA BLOCKS AND SAVE FRAMES =====
// Reference: CIF 2.0 EBNF structural productions

// CIF 2.0 EBNF: container-code = non-blank-char, { non-blank-char }
// Name for data blocks (1+ non-blank characters in CIF 2.0)
//
// IMPLEMENTATION: Allow 0+ characters for CIF 1.1 backward compatibility
// Semantic validation enforces 1+ for CIF 2.0 files with magic header
container_code = { non_blank_char* }

// Save frame names (both CIF 1.1 and CIF 2.0 require 1+ characters)
// This is defined separately from container_code to emit Rule::framename token
framename = { non_blank_char+ }

// CIF 2.0 EBNF: data-heading = data-token, container-code
// Data block header: "data_" followed by block name
data_heading = { data_token ~ container_code }

// CIF 2.0 EBNF: save-heading = save-token, container-code
// Save frame header: "save_" followed by frame name
// NOTE: Uses framename (1+ chars) instead of container_code for proper validation
save_heading = { save_token ~ framename }

// End frame marker: "save_" with no name
endframe = { save_token }

// Backward compatibility aliases (CIF 1.1 naming)
datablockname = { container_code }
datablockheading = { data_heading | global_token }

// ===== PART 9: DATA ITEMS AND LOOPS =====
// Reference: CIF 2.0 EBNF data productions

// Missing value detection (for error handling)
missing_value = { &(SOI | "\n") }

// Data item: tag followed by value
dataitem = {
    item_tag ~ wspace ~ (item_value ~ ws_or_eof | missing_value)
}

// CIF 2.0 EBNF: data-loop = loop-token, wspace, data-name, { wspace, data-name },
//                          wspace-data-value, { wspace-data-value }
// Loop structure: "loop_" keyword, tags, then values
loop_values = {
    loop_value ~ (whitespace ~ loop_value)* ~ ws_or_eof
}

loop_end = { (stop_token ~ ws_or_eof)? }

loop_block = {
    loop_token ~ wspace ~
    (loop_tag ~ wspace)+ ~
    (loop_values | &(keyword | EOI)) ~
    loop_end
}

// ===== PART 10: SAVE FRAMES =====
// Reference: CIF 2.0 EBNF save-frame production

// CIF 2.0 EBNF: save-frame = save-heading, { frame-content }, wspace, save-token
// Save frame: header, content, closing "save_"
frame = {
    save_heading ~ ws_or_eof ~
    (dataitem | loop_block)* ~
    endframe ~ ws_or_eof
}

// ===== PART 11: DATA BLOCKS =====
// Reference: CIF 2.0 EBNF data-block production

// CIF 2.0 EBNF: data-block = data-heading, { block-content }
// Data block: header followed by content (data items, loops, save frames)
data_block = {
    data_heading ~ ws_or_eof ~
    (dataitem | loop_block | frame)*
}

// Backward compatibility alias (CIF 1.1 naming)
datablock = { datablockheading ~ ws_or_eof ~ (dataitem | loop_block | frame)* }

// ===== PART 12: CIF FILE STRUCTURE =====
// Reference: CIF 2.0 EBNF CIF2-file production

// CIF 2.0 EBNF: magic-code = '#\#CIF_2.0'
// Version identifier for CIF 2.0 files
// Note: File content is literally: # \ # C I F _ 2 . 0 (with backslash)
// In Pest, backslash is escaped as \\ in string literals
magic_code = { "#\\#CIF_2.0" }

// CIF 2.0 EBNF: file-heading = [ ?U+FEFF? ], magic-code, { inline-wspace }
// Optional: BOM, magic comment, trailing whitespace
file_heading = { "\u{FEFF}"? ~ magic_code ~ inline_wspace* }

// CIF 2.0 EBNF: CIF2-file = ( file-heading, [ line-term, [
//                            wspace-any, data-block,
//                            { wspace, data-block } ], [ wspace ], [ comment ] ] )
//                          - ( { allchars }, 2049 * char, { allchars } )
//
// Note: 2048 character line limit is validated during parsing, not in grammar
//
// For backward compatibility: magic comment is optional
// - If present → CIF 2.0
// - If absent → CIF 1.1 (or CIF 2.0 without magic comment)
file = {
    SOI ~
    file_heading? ~
    wspace_any ~
    (!EOI ~ datablock+ ~ wspace?)? ~
    EOI
}

// Content (data blocks only, for streaming)
content = { datablock+ }

// Single block parsing (for streaming)
one_block = { wspace? ~ (!EOI ~ datablock) }

// ===== END OF CIF 2.0 GRAMMAR =====
//
// This grammar implements the CIF 2.0 EBNF specification with backward
// compatibility for CIF 1.1 files. Version detection is done at parse time
// based on the presence of the magic comment.
//
// Key CIF 2.0 features:
// - Unicode character support (UTF-8)
// - Triple-quoted strings ("""...""" and '''...''')
// - Lists ([value1 value2 value3])
// - Tables ({key1:value1 key2:value2})
// - Newlines allowed in quoted strings
// - Stricter container naming (1+ characters required)
//
// See docs/reference/cif-versions.md for complete documentation.
// ================================================================================
