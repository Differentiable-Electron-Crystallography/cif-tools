// CIF 1.1 Grammar in Pest PEG format
// Based on: https://www.iucr.org/resources/cif/spec/version1.1/cifsyntax
// Paragraphs refer to formal grammar's defined at the URL.

// ===== PART 1: BASIC CHARACTER SETS =====
// Reference: Table 2.2.7.1 - Printable character set

// Paragraph 42: OrdinaryChar
// An "ordinary character", <OrdinaryChar>, is any character that may be used in an
// unquoted string, excluding the special characters used as separators in the syntax.
// Production: <OrdinaryChar> ::= ! % & ()*+,-./0-9:  <=>?@A-Z[]  \ ^  `a-z{|}~
ordinary_char = {
    "!"
  | "%"
  | "&"
  | "("
  | ")"
  | "*"
  | "+"
  | ","
  | "-"
  | "."
  | "/"
  | '0'..'9'
  | ":"
  | "<"
  | "="
  | ">"
  | "?"
  | "@"
  | 'A'..'Z'
  | "["
  | "]"
  | "\\"
  | "^"
  | "`"
  | 'a'..'z'
  | "{"
  | "|"
  | "}"
  | "~"
}

// Paragraph 41: NonBlankChar
// A "non-blank character", <NonBlankChar>, is any printable character other than a
// space <SP>, a tab <HT> or the special character _.
// Production: <NonBlankChar> ::= !"#$%&'()*+,-./0-9:;<=>?@A-Z[\]^_`a-z{|}~
nonblank_ch = { '\x21'..'\x7E' }
// '!' through '~'

// Paragraph 40: AnyPrintChar
// An "any print character", <AnyPrintChar>, is a printable character, a <SP>
// character or a <HT> character.
// Production: <AnyPrintChar> ::= <SP> | <HT> | !"#$%&'()*+,-./0-9:;<=>?@A-Z[\]^_`a-z{|}~
anyprint_ch = { ' '..'~' | "\t" }

// Paragraph 43: WhiteSpace
// "White space", <WhiteSpace>, is the generalization of the ASCII <SP> character,
// and includes the characters <SP>, <HT>, <eol> and the comments.
// Production: <WhiteSpace> ::= {<SP> | <HT> | <eol> | <Comments> | <TokenizedComments>}+
ws_char = { " " | "\t" | "\n" | "\r" }

// ===== PART 2: COMMENTS AND WHITESPACE =====

// Paragraph 45: Comments
// A "comment" is defined to be initiated with the character # followed by any sequence
// of characters. The only characters not allowed are those in the production <eol>,
// which <eol> terminates a comment.
// Production: <Comments> ::= { '#' {<AnyPrintChar>}* <eol>}+
comment = { "#" ~ (!"\n" ~ ANY)* }

// Paragraph 45: TokenizedComments
// Comments recognized after blanks (space, tab or <eol>)
// Production: <TokenizedComments> ::= { <SP> | <HT> | <eol> |}+ <Comments>
// Note: In Pest, this is handled by the whitespace rule composition

// Paragraph 43: WhiteSpace (implementation)
// Combining ws_char and comments as per the production
whitespace = { (ws_char | comment)+ }

// Helper: WhiteSpace or EOF
ws_or_eof = { whitespace | EOI }

// ===== PART 3: RESERVED WORDS =====
// Paragraph 19: Reserved words

// Paragraph 27: Data block header
// A "data block header", data_<blockname>, signals the beginning of a data block
// Production: data_<blockname> where <blockname> is {<NonBlankChar>}+
str_data = { ^"data_" }

// Paragraph 19: loop_ keyword
// The STAR keyword loop_ signals that the next list of data names should be
// collected together in a table of data values.
// Production: loop_ (case-insensitive)
str_loop = { ^"loop_" ~ &ws_or_eof }

// Paragraph 29: Global block
// A "global block" is opened by the reserved word global_ appearing in the first
// column of a line, followed by white space.
// Production: global_
str_global = { ^"global_" ~ &ws_or_eof }

// Paragraph 30: Save frame
// A "save frame" is bounded by the reserved word save_ appearing in the first column
// of a line and begins with save_<framename>
// Production: save_<framename> where <framename> is {<NonBlankChar>}+
str_save = { ^"save_" }

// Paragraph 19: stop_ keyword
// The stop_ reserved word was used in earlier STAR proposals to close a loop structure
// Production: stop_ (now deprecated but still recognized)
str_stop = { ^"stop_" ~ &ws_or_eof }

// Combined keywords
keyword = { str_data | str_loop | str_global | str_save | str_stop }

// ===== PART 4: CHARACTER STRINGS =====
// Paragraph 20: Quoted strings

// Helper for end of quoted string detection
endq_single = { "'" ~ &(ws_char | "#" | EOI) }
endq_double = { "\"" ~ &(ws_char | "#" | EOI) }

// Paragraph 20: Single-quoted string
// A string of characters bounded by single quote characters (') (ASCII 39)
// Production: <SingleQuotedString> ::= <single_quote>{<AnyPrintChar>}*<single_quote>
singlequoted = { "'" ~ (!endq_single ~ !"\n" ~ ANY)* ~ endq_single }

// Paragraph 20: Double-quoted string
// A string of characters bounded by double quote characters (") (ASCII 34)
// Production: <DoubleQuotedString> ::= <double_quote>{<AnyPrintChar>}*<double_quote>
doublequoted = { "\"" ~ (!endq_double ~ !"\n" ~ ANY)* ~ endq_double }

// Paragraph 21: Text field
// A "text field" is a character string starting with a semicolon character ;
// as the first character of a line.
// Production: <TextField> ::= <semicolon><eol>{{<AnyPrintChar>}*<eol>}*<semicolon>
//
// FIXED: Rewrote textfield rule to properly handle text fields in document context.
// The previous field_sep-based implementation failed when text fields appeared
// within data blocks because field_sep required SOI (start of input) or \n;,
// but couldn't match the ending semicolon correctly in document parsing.
//
// New implementation directly matches:
// - ";" followed by newline, content (until \n; or EOI), newline, ";" OR
// - ";" followed by content (until \n; or EOI), newline, ";"
// This handles both multi-line text fields and single-line text fields correctly.
textfield = {
    (";" ~ "\n" ~ (!(("\n" ~ ";") | EOI) ~ ANY)* ~ "\n" ~ ";") |
    (";" ~ (!(("\n" ~ ";") | EOI) ~ ANY)* ~ "\n" ~ ";")
}

// Paragraph 20: Unquoted string
// An unquoted string is a contiguous string of non-white-space characters, which
// starts with an ordinary character
// Production: <UnquotedString> ::= <OrdinaryChar>{<NonBlankChar>}*
unquoted = {
    !keyword ~ !(^"_" | "$" | "#") ~ nonblank_ch+
}

// Optimization: simple unquoted (ordinary chars only)
simunq = { ordinary_char+ ~ &ws_char }

// ===== PART 5: DATA NAMES (TAGS) =====

// Paragraph 18: Data names
// A "data name" is a character string starting with an underscore character <_>.
// Production: <Tag> ::= <underscore>{<NonBlankChar>}+
tag = { "_" ~ nonblank_ch+ }

// ===== PART 6: DATA VALUES =====

// Paragraph 15: Data values
// The syntax of data values within CIFs is fully defined
// Production: <Value> ::= {'.'}|{'?'}|{<Numeric>}|{<CharString>}|{<TextField>}
value = { simunq | singlequoted | doublequoted | textfield | unquoted }

// Specific tag and value types for parsing context
item_tag   = { tag }
item_value = { value }
loop_tag   = { tag }
loop_value = { value }

// ===== PART 7: DATA BLOCKS AND GLOBAL BLOCKS =====

// Paragraph 27: Data block name
// Production: <DataBlockName> ::= {<NonBlankChar>}*
datablockname = { nonblank_ch* }

// Paragraph 27/29: Block heading
// Either data_ with name OR global_
// Production: <DataBlockHeading> ::= <data>{<NonBlankChar>}+ | <global>
datablockheading = { (str_data ~ datablockname) | str_global }

// Paragraph 30: Save frame name
// Production: <FrameName> ::= {<NonBlankChar>}+
framename = { nonblank_ch+ }

// End frame marker
endframe = { str_save }

// ===== PART 8: DATA ITEMS AND LOOPS =====

// Missing value detection (for error handling)
missing_value = { &(SOI | "\n") }

// Paragraph 16: Data items
// A "data item" is a data name followed by an associated data value
// Production: <DataItem> ::= <Tag> <WhiteSpace> <Value>
dataitem = {
    item_tag ~ whitespace ~ (item_value ~ ws_or_eof | missing_value)
}

// Loop termination
loop_end = { (str_stop ~ ws_or_eof)? }

// Loop values section
// Production: <LoopBody> ::= {<Value> <WhiteSpace>}+
loop_values = {
    loop_value ~ (whitespace ~ loop_value)* ~ ws_or_eof
}

// Paragraph 19: Loop structure
// A "looped list" of data values is a list of data values preceded by a list
// of data names, preceded by the reserved case-insensitive word loop_
// Production: <Loop> ::= <loop> {<Tag> <WhiteSpace>}+ <LoopBody>
loop_block = {
    str_loop ~ whitespace ~ (loop_tag ~ whitespace)+ ~ (loop_values | &(keyword | EOI)) ~ loop_end
}

// Paragraph 30: Save frame
// A "save frame" is bounded by the reserved word save_
// Production: <SaveFrame> ::= <save>{<NonBlankChar>}+ {<DataItem>|<Loop>}* <save>
frame = {
    str_save ~ framename ~ whitespace ~ (dataitem | loop_block)* ~ endframe ~ ws_or_eof
}

// Paragraph 27: Data block
// A "data block" is a logical grouping of data items, save frames and loops
// Production: <DataBlock> ::= <DataBlockHeading> {<WhiteSpace> {<DataItem>|<SaveFrame>|<Loop>}}*
datablock = {
    datablockheading ~ ws_or_eof ~ (dataitem | loop_block | frame)*
}

// ===== PART 9: CIF FILE STRUCTURE =====

// Paragraph 11: CIF content
// A CIF is a sequence of data blocks
// Production: <CIF> ::= {<DataBlock>}+ | {<WhiteSpace>}
content = { datablock+ }

// Complete CIF file
// Production: <CIF> ::= {<Comments>}? {<DataBlock>}+ {<WhiteSpace>}?
file = {
    SOI ~ whitespace? ~ (!EOI ~ content ~ EOI)?
}

// Single block parsing (for streaming)
one_block = {
    whitespace? ~ (!EOI ~ datablock)
}

// ===== END OF CIF 1.1 GRAMMAR =====
